{"entries":[{"timestamp":1748235290087,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":197,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":226,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"custom.ts","value":"//% color=\"#4CAF50\" weight=100 icon=\"\\uf043\"\nnamespace ripples {\n\n    export interface RippleOptions {\n        //% block=\"duration (ms)\" min=100 max=5000\n        duration?: number;\n        //% block=\"max radius\" min=10 max=100\n        maxRadius?: number;\n        //% block=\"color\"\n        color?: number;\n        //% block=\"line width\" min=1 max=5\n        lineWidth?: number;\n        //% block=\"fade out\"\n        fadeOut?: boolean;\n    }\n\n    interface ActiveRipple {\n        x: number;\n        y: number;\n        currentRadius: number;\n        maxRadius: number;\n        color: number;\n        lineWidth: number;\n        startTime: number;\n        duration: number;\n        fadeOut: boolean;\n    }\n\n    let activeRipples: ActiveRipple[] = [];\n    let rippleUpdateRegistered = false;\n\n    /**\n     * Create a ripple effect at the specified position\n     * @param x the x coordinate for the ripple center\n     * @param y the y coordinate for the ripple center\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripple at x $x y $y || with options $options\"\n    //% x.defl=80 y.defl=60\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createRipple(x: number, y: number, options?: RippleOptions) {\n        const ripple: ActiveRipple = {\n            x: x,\n            y: y,\n            currentRadius: 0,\n            maxRadius: options?.maxRadius || 30,\n            color: options?.color || 1,\n            lineWidth: options?.lineWidth || 2,\n            startTime: game.runtime(),\n            duration: options?.duration || 1000,\n            fadeOut: options?.fadeOut !== false\n        };\n\n        activeRipples.push(ripple);\n\n        if (!rippleUpdateRegistered) {\n            registerRippleUpdate();\n        }\n    }\n\n    /**\n     * Create a ripple effect at a sprite's position\n     * @param sprite the sprite to create a ripple at\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripple at sprite $sprite || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createRippleAtSprite(sprite: Sprite, options?: RippleOptions) {\n        createRipple(sprite.x, sprite.y, options);\n    }\n\n    /**\n     * Create multiple ripples in a pattern\n     * @param centerX center x coordinate\n     * @param centerY center y coordinate\n     * @param count number of ripples\n     * @param delay delay between ripples in ms\n     * @param options ripple configuration options\n     */\n    //% block=\"create $count ripples at x $centerX y $centerY with $delay ms delay || options $options\"\n    //% count.defl=3 centerX.defl=80 centerY.defl=60 delay.defl=200\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createMultipleRipples(centerX: number, centerY: number, count: number, delay: number, options?: RippleOptions) {\n        for (let i = 0; i < count; i++) {\n            timer.after(i * delay, () => {\n                createRipple(centerX, centerY, options);\n            });\n        }\n    }\n\n    /**\n     * Create a ripple when a sprite is clicked\n     * @param sprite the sprite to add click ripples to\n     * @param options ripple configuration options\n     */\n    //% block=\"add click ripples to sprite $sprite || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function addClickRipples(sprite: Sprite, options?: RippleOptions) {\n        sprite.onDestroyed(() => {\n            createRippleAtSprite(sprite, options);\n        });\n    }\n\n    /**\n     * Create ripples when sprites overlap\n     * @param spriteKind1 first sprite kind\n     * @param spriteKind2 second sprite kind\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripples when $spriteKind1 overlaps $spriteKind2 || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function addOverlapRipples(spriteKind1: number, spriteKind2: number, options?: RippleOptions) {\n        sprites.onOverlap(spriteKind1, spriteKind2, (sprite1, sprite2) => {\n            const x = (sprite1.x + sprite2.x) / 2;\n            const y = (sprite1.y + sprite2.y) / 2;\n            createRipple(x, y, options);\n        });\n    }\n\n    /**\n     * Clear all active ripples\n     */\n    //% block=\"clear all ripples\"\n    //% group=\"Ripple Effects\"\n    export function clearAllRipples() {\n        activeRipples = [];\n    }\n\n    /**\n     * Set default ripple color\n     * @param color the color to use for ripples\n     */\n    //% block=\"set default ripple color to $color\"\n    //% color.shadow=\"colorindexpicker\"\n    //% group=\"Settings\"\n    export function setDefaultColor(color: number) {\n        defaultRippleColor = color;\n    }\n\n    let defaultRippleColor = 1;\n\n    function registerRippleUpdate() {\n        rippleUpdateRegistered = true;\n\n        game.onPaint(() => {\n            for (let i = activeRipples.length - 1; i >= 0; i--) {\n                const ripple = activeRipples[i];\n                const elapsed = game.runtime() - ripple.startTime;\n                const progress = elapsed / ripple.duration;\n\n                if (progress >= 1) {\n                    // Remove completed ripples\n                    activeRipples.removeAt(i);\n                    continue;\n                }\n\n                // Calculate current radius\n                ripple.currentRadius = ripple.maxRadius * progress;\n\n                // Calculate alpha for fade out\n                let alpha = 255;\n                if (ripple.fadeOut) {\n                    alpha = Math.round(255 * (1 - progress));\n                }\n\n                // Draw the ripple\n                drawRipple(ripple, alpha);\n            }\n        });\n    }\n\n    function drawRipple(ripple: ActiveRipple, alpha: number) {\n        // Draw circle outline for ripple effect\n        const radius = Math.round(ripple.currentRadius);\n\n        // Simple circle drawing using pixels\n        for (let angle = 0; angle < 360; angle += 2) {\n            const radian = angle * Math.PI / 180;\n            const x = Math.round(ripple.x + Math.cos(radian) * radius);\n            const y = Math.round(ripple.y + Math.sin(radian) * radius);\n\n            // Check bounds\n            if (x >= 0 && x < screen.width && y >= 0 && y < screen.height) {\n                // Draw pixel with fade effect\n                if (alpha > 50) { // Only draw if visible enough\n                    screen.setPixel(x, y, ripple.color);\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a splash ripple effect (multiple expanding rings)\n     * @param x center x coordinate\n     * @param y center y coordinate\n     * @param options ripple configuration options\n     */\n    //% block=\"create splash at x $x y $y || with options $options\"\n    //% x.defl=80 y.defl=60\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Special Effects\"\n    export function createSplash(x: number, y: number, options?: RippleOptions) {\n        createMultipleRipples(x, y, 3, 150, options);\n    }\n\n    /**\n     * Create a pulsing ripple effect\n     * @param x center x coordinate\n     * @param y center y coordinate\n     * @param pulses number of pulses\n     * @param options ripple configuration options\n     */\n    //% block=\"create $pulses pulses at x $x y $y || with options $options\"\n    //% pulses.defl=5 x.defl=80 y.defl=60\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Special Effects\"\n    export function createPulse(x: number, y: number, pulses: number, options?: RippleOptions) {\n        for (let i = 0; i < pulses; i++) {\n            timer.after(i * 300, () => {\n                createRipple(x, y, {\n                    ...options,\n                    maxRadius: (options?.maxRadius || 20) + (i * 5)\n                });\n            });\n        }\n    }\n}\n"}]},{"timestamp":1748235298934,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"custom.ts","patch":[{"start1":0,"length1":338,"diffs":[[1,"//% color=\"#4CAF50\" weight=100 icon=\"\\uf043\"\nnamespace ripples {\n\n    export interface RippleOptions {\n        //% block=\"duration (ms)\" min=100 max=5000\n        duration?: number;\n        //% block=\"max radius\" min=10 max=100\n        maxRadius?: number;\n        //% block=\"color\"\n        color?: number;\n        //% block=\"line width\" min=1 max=5\n        lineWidth?: number;\n        //% block=\"fade out\"\n        fadeOut?: boolean;\n"]]},{"start1":439,"length1":72,"diffs":[[1,"    interface ActiveRipple {\n        x: number;\n        y: number;\n        currentRadius: number;\n        maxRadius: number;\n        color: number;\n        lineWidth: number;\n        startTime: number;\n        duration: number;\n        fadeOut: boolean;\n    }\n"]]},{"start1":700,"length1":174,"diffs":[[1,"    let activeRipples: ActiveRipple[] = [];\n    let rippleUpdateRegistered = false;\n"]]},{"start1":785,"length1":254,"diffs":[[1,"    /**\n     * Create a ripple effect at the specified position\n     * @param x the x coordinate for the ripple center\n     * @param y the y coordinate for the ripple center\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripple at x $x y $y || with options $options\"\n    //% x.defl=80 y.defl=60\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createRipple(x: number, y: number, options?: RippleOptions) {\n        const ripple: ActiveRipple = {\n            x: x,\n            y: y,\n            currentRadius: 0,\n            maxRadius: options?.maxRadius || 30,\n            color: options?.color || 1,\n            lineWidth: options?.lineWidth || 2,\n            startTime: game.runtime(),\n            duration: options?.duration || 1000,\n            fadeOut: options?.fadeOut !== false\n        };\n"]]},{"start1":1657,"length1":138,"diffs":[[1,"        activeRipples.push(ripple);\n"]]},{"start1":1694,"length1":544,"diffs":[[1,"        if (!rippleUpdateRegistered) {\n            registerRippleUpdate();\n"]]},{"start1":1786,"length1":311,"diffs":[[1,"    /**\n     * Create a ripple effect at a sprite's position\n     * @param sprite the sprite to create a ripple at\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripple at sprite $sprite || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createRippleAtSprite(sprite: Sprite, options?: RippleOptions) {\n        createRipple(sprite.x, sprite.y, options);\n"]]},{"start1":2246,"length1":288,"diffs":[[1,"    /**\n     * Create multiple ripples in a pattern\n     * @param centerX center x coordinate\n     * @param centerY center y coordinate\n     * @param count number of ripples\n     * @param delay delay between ripples in ms\n     * @param options ripple configuration options\n     */\n    //% block=\"create $count ripples at x $centerX y $centerY with $delay ms delay || options $options\"\n    //% count.defl=3 centerX.defl=80 centerY.defl=60 delay.defl=200\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function createMultipleRipples(centerX: number, centerY: number, count: number, delay: number, options?: RippleOptions) {\n        for (let i = 0; i < count; i++) {\n            timer.after(i * delay, () => {\n                createRipple(centerX, centerY, options);\n            });\n"]]},{"start1":3078,"length1":300,"diffs":[[1,"    /**\n     * Create a ripple when a sprite is clicked\n     * @param sprite the sprite to add click ripples to\n     * @param options ripple configuration options\n     */\n    //% block=\"add click ripples to sprite $sprite || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function addClickRipples(sprite: Sprite, options?: RippleOptions) {\n        sprite.onDestroyed(() => {\n            createRippleAtSprite(sprite, options);\n        });\n"]]},{"start1":3581,"length1":154,"diffs":[[1,"    /**\n     * Create ripples when sprites overlap\n     * @param spriteKind1 first sprite kind\n     * @param spriteKind2 second sprite kind\n     * @param options ripple configuration options\n     */\n    //% block=\"create ripples when $spriteKind1 overlaps $spriteKind2 || with options $options\"\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Ripple Effects\"\n    export function addOverlapRipples(spriteKind1: number, spriteKind2: number, options?: RippleOptions) {\n        sprites.onOverlap(spriteKind1, spriteKind2, (sprite1, sprite2) => {\n            const x = (sprite1.x + sprite2.x) / 2;\n            const y = (sprite1.y + sprite2.y) / 2;\n            createRipple(x, y, options);\n        });\n"]]},{"start1":4292,"length1":178,"diffs":[[1,"    /**\n     * Clear all active ripples\n     */\n    //% block=\"clear all ripples\"\n    //% group=\"Ripple Effects\"\n    export function clearAllRipples() {\n        activeRipples = [];\n"]]},{"start1":4480,"length1":223,"diffs":[[1,"    /**\n     * Set default ripple color\n     * @param color the color to use for ripples\n     */\n    //% block=\"set default ripple color to $color\"\n    //% color.shadow=\"colorindexpicker\"\n    //% group=\"Settings\"\n    export function setDefaultColor(color: number) {\n        defaultRippleColor = color;\n"]]},{"start1":4789,"length1":236,"diffs":[[1,"    let defaultRippleColor = 1;\n"]]},{"start1":4822,"length1":225,"diffs":[[1,"    function registerRippleUpdate() {\n        rippleUpdateRegistered = true;\n"]]},{"start1":4900,"length1":244,"diffs":[[1,"        game.onPaint(() => {\n            for (let i = activeRipples.length - 1; i >= 0; i--) {\n                const ripple = activeRipples[i];\n                const elapsed = game.runtime() - ripple.startTime;\n                const progress = elapsed / ripple.duration;\n"]]},{"start1":5172,"length1":271,"diffs":[[1,"                if (progress >= 1) {\n                    // Remove completed ripples\n                    activeRipples.removeAt(i);\n                    continue;\n                }\n"]]},{"start1":5353,"length1":163,"diffs":[[1,"                // Calculate current radius\n                ripple.currentRadius = ripple.maxRadius * progress;\n"]]},{"start1":5466,"length1":140,"diffs":[[1,"                // Calculate alpha for fade out\n                let alpha = 255;\n                if (ripple.fadeOut) {\n                    alpha = Math.round(255 * (1 - progress));\n                }\n\n                // Draw the ripple\n                drawRipple(ripple, alpha);\n            }\n        });\n"]]},{"start1":5777,"length1":382,"diffs":[[1,"    function drawRipple(ripple: ActiveRipple, alpha: number) {\n        // Draw circle outline for ripple effect\n        const radius = Math.round(ripple.currentRadius);\n"]]},{"start1":5947,"length1":156,"diffs":[[1,"        // Simple circle drawing using pixels\n        for (let angle = 0; angle < 360; angle += 2) {\n            const radian = angle * Math.PI / 180;\n            const x = Math.round(ripple.x + Math.cos(radian) * radius);\n            const y = Math.round(ripple.y + Math.sin(radian) * radius);\n"]]},{"start1":6243,"length1":153,"diffs":[[1,"            // Check bounds\n            if (x >= 0 && x < screen.width && y >= 0 && y < screen.height) {\n                // Draw pixel with fade effect\n                if (alpha > 50) { // Only draw if visible enough\n                    screen.setPixel(x, y, ripple.color);\n                }\n            }\n"]]},{"start1":6566,"length1":108,"diffs":[[1,"    /**\n     * Create a splash ripple effect (multiple expanding rings)\n     * @param x center x coordinate\n     * @param y center y coordinate\n     * @param options ripple configuration options\n     */\n    //% block=\"create splash at x $x y $y || with options $options\"\n"]]},{"start1":6865,"length1":36,"diffs":[[1,""]]},{"start1":6905,"length1":382,"diffs":[[1,"    //% group=\"Special Effects\"\n    export function createSplash(x: number, y: number, options?: RippleOptions) {\n        createMultipleRipples(x, y, 3, 150, options);\n"]]},{"start1":7080,"length1":1385,"diffs":[[1,"    /**\n     * Create a pulsing ripple effect\n     * @param x center x coordinate\n     * @param y center y coordinate\n     * @param pulses number of pulses\n     * @param options ripple configuration options\n     */\n    //% block=\"create $pulses pulses at x $x y $y || with options $options\"\n    //% pulses.defl=5 x.defl=80 y.defl=60\n    //% expandableArgumentMode=\"toggle\"\n    //% group=\"Special Effects\"\n    export function createPulse(x: number, y: number, pulses: number, options?: RippleOptions) {\n        for (let i = 0; i < pulses; i++) {\n            timer.after(i * 300, () => {\n                createRipple(x, y, {\n                    ...options,\n                    maxRadius: (options?.maxRadius || 20) + (i * 5)\n                });\n            });\n"]]}]}]},{"timestamp":1748236003473,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]}]},{"timestamp":1748236007332,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":444,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":53,"diffs":[[1,"    \"name\": \"ripples from ripple nursary\",\n"]]},{"start1":90,"length1":81,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":247,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1753671352396,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":494,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"f~K^+@D,2t!3Z82p:e-:\">mySprite</variable><variable type=\"KIND_SpriteKind\" id=\"%f_lby_1nvZW#NLy6x-{\">Player</variable><variable type=\"KIND_SpriteKind\" id=\"Sn2I4Xx,i%p^p]-M@_]4\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"jA-2`yJAm5D5WIM*JRw*\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"nPn]gt=6.G1^#lZXmU`?\">Enemy</variable></variables></xml>"]]}]}]},{"timestamp":1753671358331,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":444,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"f~K^+@D,2t!3Z82p:e-:\">mySprite</variable><variable type=\"KIND_SpriteKind\" id=\"%f_lby_1nvZW#NLy6x-{\">Player</variable><variable type=\"KIND_SpriteKind\" id=\"Sn2I4Xx,i%p^p]-M@_]4\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"jA-2`yJAm5D5WIM*JRw*\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"nPn]gt=6.G1^#lZXmU`?\">Enemy</variable></variables><block type=\"pxt-on-start\" x=\"24\" y=\"154\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":316,"length1":75,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"edited","filename":"custom.ts","patch":[{"start1":126,"length1":0,"diffs":[[1,"    // Ripple configuration\n"]]},{"start1":344,"length1":0,"diffs":[[1,"\n    // Array to store all active ripples\n"]]},{"start1":986,"length1":0,"diffs":[[1,"\n            // Clear points array before updating\n"]]},{"start1":1066,"length1":0,"diffs":[[1,"\n            // Only generate points if ripple is still active\n"]]},{"start1":2291,"length1":0,"diffs":[[1,"        // Filter out completed ripples and update remaining ones\n"]]},{"start1":5655,"length1":5,"diffs":[[1,"\n    // Internal function for drawing connected ripples\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1748235290086,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ripples from ripple nursary\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1753671352396,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"f~K^+@D,2t!3Z82p:e-:\">mySprite</variable><variable type=\"KIND_SpriteKind\" id=\"%f_lby_1nvZW#NLy6x-{\">Player</variable><variable type=\"KIND_SpriteKind\" id=\"Sn2I4Xx,i%p^p]-M@_]4\">Projectile</variable><variable type=\"KIND_SpriteKind\" id=\"jA-2`yJAm5D5WIM*JRw*\">Food</variable><variable type=\"KIND_SpriteKind\" id=\"nPn]gt=6.G1^#lZXmU`?\">Enemy</variable></variables></xml>","main.ts":"","README.md":" ","assets.json":"","custom.ts":"//% color=#0099CC icon=\"\\uf043\" block=\"Ripples\"\n//% groups=['Create', 'Update', 'Configure', 'Info']\nnamespace RippleSystem {\n    // Ripple configuration\n    export const WATER = {\n        rippleCount: 4,\n        rippleSpeed: 0.6,\n        rippleSize: 60,\n        rippleColor: 8,\n        edgeThickness: 20,\n        connectionDistance: 20,\n    }\n\n    // Array to store all active ripples\n    let ripples: Ripple[] = []\n\n    export class Ripple {\n        x: number\n        y: number\n        size: number\n        maxSize: number\n        points: { x: number, y: number }[]\n        opacity: number\n\n        constructor(x: number, y: number) {\n            this.x = x\n            this.y = y\n            this.size = 0\n            this.maxSize = WATER.rippleSize + Math.randomRange(-5, 5)\n            this.opacity = 1\n            this.points = []\n        }\n\n        update() {\n            this.size += WATER.rippleSpeed\n            this.opacity = Math.max(0, 1 - (this.size / this.maxSize) ** 2)\n\n            // Clear points array before updating\n            this.points = []\n\n            // Only generate points if ripple is still active\n            if (this.opacity > 0) {\n                const steps = 50\n                for (let i = 0; i < steps; i++) {\n                    const angle = (i / steps) * Math.PI * 2\n                    this.points.push({\n                        x: this.x + Math.cos(angle) * this.size,\n                        y: this.y + Math.sin(angle) * this.size\n                    })\n                }\n            }\n        }\n    }\n\n    //% block=\"create ripple at x $x y $y\"\n    //% group=\"Create\"\n    //% x.defl=80 y.defl=60\n    //% weight=100\n    export function createRipple(x: number, y: number): void {\n        if (ripples.length < WATER.rippleCount) {\n            let ripple = new Ripple(x, y)\n            ripples.push(ripple)\n        }\n    }\n\n    //% block=\"create ripple at $sprite position\"\n    //% group=\"Create\"\n    //% sprite.shadow=variables_get\n    //% sprite.defl=mySprite\n    //% weight=95\n    export function createRippleAtSprite(sprite: Sprite): void {\n        if (sprite) {\n            createRipple(sprite.x, sprite.y)\n        }\n    }\n\n    //% block=\"update all ripples\"\n    //% group=\"Update\"\n    //% weight=90\n    export function updateRipples(): void {\n        // Filter out completed ripples and update remaining ones\n        ripples = ripples.filter(ripple => ripple.opacity > 0)\n        ripples.forEach(ripple => ripple.update())\n    }\n\n    //% block=\"draw all ripples\"\n    //% group=\"Update\"\n    //% weight=85\n    export function drawRipples(): void {\n        drawConnectedRipples(ripples)\n    }\n\n    //% block=\"update and draw ripples\"\n    //% group=\"Update\"\n    //% weight=80\n    export function updateAndDrawRipples(): void {\n        updateRipples()\n        drawRipples()\n    }\n\n    //% block=\"set max ripples to $count\"\n    //% group=\"Configure\"\n    //% count.min=1 count.max=10 count.defl=4\n    //% weight=75\n    export function setMaxRipples(count: number): void {\n        WATER.rippleCount = count\n    }\n\n    //% block=\"set ripple speed to $speed\"\n    //% group=\"Configure\"\n    //% speed.min=0.1 speed.max=2.0 speed.defl=0.6\n    //% weight=70\n    export function setRippleSpeed(speed: number): void {\n        WATER.rippleSpeed = speed\n    }\n\n    //% block=\"set ripple size to $size\"\n    //% group=\"Configure\"\n    //% size.min=10 size.max=120 size.defl=60\n    //% weight=65\n    export function setRippleSize(size: number): void {\n        WATER.rippleSize = size\n    }\n\n    //% block=\"set ripple color to $color\"\n    //% group=\"Configure\"\n    //% color.shadow=colorindexpicker\n    //% color.defl=8\n    //% weight=60\n    export function setRippleColor(color: number): void {\n        WATER.rippleColor = color\n    }\n\n    //% block=\"set connection distance to $distance\"\n    //% group=\"Configure\"\n    //% distance.min=5 distance.max=50 distance.defl=20\n    //% weight=55\n    export function setConnectionDistance(distance: number): void {\n        WATER.connectionDistance = distance\n    }\n\n    //% block=\"number of active ripples\"\n    //% group=\"Info\"\n    //% weight=50\n    export function getRippleCount(): number {\n        return ripples.length\n    }\n\n    //% block=\"clear all ripples\"\n    //% group=\"Info\"\n    //% weight=45\n    export function clearAllRipples(): void {\n        ripples = []\n    }\n\n    //% block=\"create ripple with cooldown at $sprite position || cooldown $cooldown ms\"\n    //% group=\"Create\"\n    //% sprite.shadow=variables_get\n    //% sprite.defl=mySprite\n    //% cooldown.defl=500\n    //% expandableArgumentMode=\"toggle\"\n    //% weight=88\n    export function createRippleWithCooldown(sprite: Sprite, cooldown: number = 500): void {\n        if (!sprite) return\n\n        let currentTime = game.runtime()\n        let lastRippleKey = \"lastRipple_\" + sprite.id\n        let lastRippleTime = sprite.data[lastRippleKey] || 0\n\n        if (currentTime - lastRippleTime > cooldown) {\n            createRipple(sprite.x, sprite.y)\n            sprite.data[lastRippleKey] = currentTime\n        }\n    }\n\n    //% block=\"create ripples in circle at x $x y $y || count $count radius $radius\"\n    //% group=\"Create\"\n    //% x.defl=80 y.defl=60\n    //% count.defl=3 radius.defl=20\n    //% expandableArgumentMode=\"toggle\"\n    //% weight=82\n    export function createRippleCircle(x: number, y: number, count: number = 3, radius: number = 20): void {\n        for (let i = 0; i < count; i++) {\n            let angle = (i / count) * Math.PI * 2\n            let rippleX = x + Math.cos(angle) * radius\n            let rippleY = y + Math.sin(angle) * radius\n            createRipple(rippleX, rippleY)\n        }\n    }\n\n    // Internal function for drawing connected ripples\n    function drawConnectedRipples(ripples: Ripple[]): void {\n        let allPoints: { x: number, y: number, opacity: number }[] = []\n\n        ripples.forEach(ripple => {\n            if (ripple.opacity > 0.2) {\n                ripple.points.forEach(point => {\n                    allPoints.push({\n                        x: point.x,\n                        y: point.y,\n                        opacity: ripple.opacity\n                    })\n                })\n            }\n        })\n\n        for (let i = 0; i < allPoints.length; i++) {\n            for (let j = i + 1; j < allPoints.length; j++) {\n                const p1 = allPoints[i]\n                const p2 = allPoints[j]\n                const dist = Math.sqrt(\n                    (p1.x - p2.x) * (p1.x - p2.x) +\n                    (p1.y - p2.y) * (p1.y - p2.y)\n                )\n\n                if (dist < WATER.connectionDistance) {\n                    const lineOpacity = (p1.opacity + p2.opacity) / 2\n                    if (lineOpacity > 0.25) {\n                        scene.backgroundImage().drawLine(\n                            p1.x,\n                            p1.y,\n                            p2.x,\n                            p2.y,\n                            WATER.rippleColor\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n","pxt.json":"{\n    \"name\": \"ripples from ripple nursary extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Timers\": \"github:microsoft/arcade-timers#v1.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"custom.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1753671643904}